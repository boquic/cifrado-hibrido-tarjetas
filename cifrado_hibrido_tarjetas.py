# -*- coding: utf-8 -*-
"""cifrado-hibrido-tarjetas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QV7eQKg-x65BmKVCizbGs9fOdIqCRqgT
"""

!pip install pycryptodome

from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import base64

def generar_claves_rsa():
    """Genera un par de claves RSA (privada y pública)"""
    key = RSA.generate(2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    return private_key, public_key

def cifrar_tarjeta(numero_tarjeta, public_key):
    """Cifra un número de tarjeta usando cifrado híbrido AES+RSA"""
    # Convertir el número de tarjeta a bytes
    data = numero_tarjeta.encode('utf-8')

    # Generar una clave AES aleatoria
    clave_aes = get_random_bytes(32)  # AES-256

    # Cifrar los datos con AES
    cipher_aes = AES.new(clave_aes, AES.MODE_CBC)
    iv = cipher_aes.iv  # Vector de inicialización
    datos_cifrados = cipher_aes.encrypt(pad(data, AES.block_size))

    # Cifrar la clave AES con RSA
    rsa_key = RSA.import_key(public_key)
    cipher_rsa = PKCS1_OAEP.new(rsa_key)
    clave_aes_cifrada = cipher_rsa.encrypt(clave_aes)

    # Retornar todos los componentes necesarios (IV, datos cifrados, clave AES cifrada)
    return {
        'iv': base64.b64encode(iv).decode('utf-8'),
        'datos_cifrados': base64.b64encode(datos_cifrados).decode('utf-8'),
        'clave_aes_cifrada': base64.b64encode(clave_aes_cifrada).decode('utf-8')
    }

def descifrar_tarjeta(datos_cifrados, private_key):
    """Descifra un número de tarjeta usando el cifrado híbrido AES+RSA"""
    # Decodificar los datos base64
    iv = base64.b64decode(datos_cifrados['iv'])
    datos_cifrados_aes = base64.b64decode(datos_cifrados['datos_cifrados'])
    clave_aes_cifrada = base64.b64decode(datos_cifrados['clave_aes_cifrada'])

    # Descifrar la clave AES con RSA
    rsa_key = RSA.import_key(private_key)
    cipher_rsa = PKCS1_OAEP.new(rsa_key)
    clave_aes = cipher_rsa.decrypt(clave_aes_cifrada)

    # Descifrar los datos con AES
    cipher_aes = AES.new(clave_aes, AES.MODE_CBC, iv=iv)
    datos_originales = unpad(cipher_aes.decrypt(datos_cifrados_aes), AES.block_size)

    return datos_originales.decode('utf-8')

# Ejemplo de uso
if __name__ == "__main__":
    # Generar claves RSA
    private_key, public_key = generar_claves_rsa()

    # Número de tarjeta de ejemplo (¡nunca uses uno real en pruebas!)
    numero_tarjeta = "412365478965"  # Ejemplo de tarjeta de prueba

    # Cifrar
    datos_cifrados = cifrar_tarjeta(numero_tarjeta, public_key)
    print("Datos cifrados:")
    print(f"IV: {datos_cifrados['iv']}")
    print(f"Datos cifrados: {datos_cifrados['datos_cifrados']}")
    print(f"Clave AES cifrada: {datos_cifrados['clave_aes_cifrada']}")

    # Descifrar
    numero_original = descifrar_tarjeta(datos_cifrados, private_key)
    print("\nNúmero de tarjeta original:", numero_original)